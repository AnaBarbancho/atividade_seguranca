<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>Cadastro Seguro</title>
  </head>
  <body>
    <h2>Cadastro com criptografia h√≠brida (AES + RSA-OAEP)</h2>

    <form id="secure-form">
      <label>Nome de usu√°rio:</label><br />
      <input type="text" name="username" required /><br /><br />

      <label>Email:</label><br />
      <input type="email" name="email" required /><br /><br />

      <label>Senha:</label><br />
      <input type="password" name="password" required /><br /><br />

      <button type="submit">Cadastrar</button>
    </form>

    <p id="response" style="font-weight:bold;"></p>

    <!-- Bibliotecas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>

    <script>
      const form = document.getElementById("secure-form");
      const responseEl = document.getElementById("response");

      form.addEventListener("submit", async (e) => {
        e.preventDefault();

        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        const payload = JSON.stringify(data);

        try {
          // 1Ô∏è‚É£ Gerar chave AES 128 bits (WordArray)
          const aesKeyWordArray = CryptoJS.lib.WordArray.random(16);
          const aesKeyBase64 = CryptoJS.enc.Base64.stringify(aesKeyWordArray);

          // 2Ô∏è‚É£ Criptografar os dados do usu√°rio com AES
          const encryptedData = CryptoJS.AES.encrypt(payload, aesKeyWordArray, {
            mode: CryptoJS.mode.ECB,
            padding: CryptoJS.pad.Pkcs7
          }).toString();

          // 3Ô∏è‚É£ Buscar chave p√∫blica do backend
          const pubKeyPem = await fetch("/crypto/public-key").then(res => {
            if (!res.ok) throw new Error("Falha ao obter chave p√∫blica");
            return res.text();
          });

          // 4Ô∏è‚É£ Criptografar a AES key com RSA-OAEP (Web Crypto API)
          const encryptedKey = await encryptAESKeyWithRSA_OAEP(pubKeyPem, aesKeyBase64);

          // 5Ô∏è‚É£ Enviar para backend
          const res = await fetch("/user/register-secure", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ encryptedKey, encryptedData })
          });

          const json = await res.json();

          if (res.ok) {
            responseEl.style.color = "green";
            responseEl.textContent = json.message;
          } else {
            responseEl.style.color = "red";
            responseEl.textContent = json.error || "Erro no cadastro";
          }

        } catch (err) {
          responseEl.style.color = "red";
          responseEl.textContent = "Erro ao enviar requisi√ß√£o";
          console.error(err);
        }
      });

      // üîë Fun√ß√£o de criptografia RSA-OAEP
      async function encryptAESKeyWithRSA_OAEP(pubKeyPem, aesKeyBase64) {
        const pemContents = pubKeyPem
          .replace(/-----BEGIN PUBLIC KEY-----/, "")
          .replace(/-----END PUBLIC KEY-----/, "")
          .replace(/\r?\n|\r/g, "")
          .trim();

        const binaryDer = window.atob(pemContents);
        const binaryDerBuffer = new Uint8Array([...binaryDer].map(c => c.charCodeAt(0)));

        const cryptoKey = await window.crypto.subtle.importKey(
          "spki",
          binaryDerBuffer,
          { name: "RSA-OAEP", hash: "SHA-256" },
          false,
          ["encrypt"]
        );

        const aesKeyBuffer = new TextEncoder().encode(aesKeyBase64);

        const encrypted = await window.crypto.subtle.encrypt(
          { name: "RSA-OAEP" },
          cryptoKey,
          aesKeyBuffer
        );

        return arrayBufferToBase64(encrypted);
      }

      function arrayBufferToBase64(buffer) {
        const binary = String.fromCharCode(...new Uint8Array(buffer));
        return window.btoa(binary);
      }
    </script>
  </body>
</html>
